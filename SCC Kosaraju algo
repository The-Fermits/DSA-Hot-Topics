#include <bits/stdc++.h>
#define ll long long
#define int long long
#define pb push_back
#define popb pop_back
#define INT_MAX 1e9+15
#define INT_MIN -(1e9+15)

using namespace std;
using vpii = vector<pair<int, int>>;
using pii = pair<int, int>;
using vi = vector<int>;
using vvi = vector<vector<int>>;
#define ff first
#define ss second
#define endl '\n'
#define all(x) x.begin(), x.end()
#define sz(x) (int)(x).size()
const int inf = 9e18;
const int mod = 1e9 + 7;
const int NUM = 1000030;
const int NN = 10000000;
//-----------------------------------------------------------------------------------------------

int n , m ; 
vvi g , grev, b_graph;
vector<int> topo ; 
vector<int> comp ;
vi vis , val;

// reverse topo 

void dfs1(int node) {
    vis[node] = 1;
    for(auto v : g[node]) {
        if(vis[v]==0) dfs1(v) ;
    }
    topo.pb(node) ;
}

void dfs2 (int node, int col) {
    comp[node] = col ; 
    for(auto v : grev[node]) {
        if(comp[v]==-1) dfs2(v,col) ;
    }
}

void solve()
{
   cin >> n >> m ; 
   g.clear(); grev.clear();
   g.resize(n+1) ; 
   grev.resize(n+1) ; 
   for (int i=0; i<m; i++){
        int x , y ; 
        cin >> x >> y ; 
        g[x].pb(y);
        grev[y].pb(x) ;
   }

   val.assign(n+1, 0);
   for (int i=1; i<=n; i++){
        cin >> val[i] ;
   }
    
   // find SCC 
   // first find topo
   topo.clear();
   vis.assign(n+1,0) ;

   for (int i=1; i<=n; i++){
        if(vis[i]==0) dfs1(i) ;
   }
    
   // now check for SCC 
   // assign components 
   comp.assign(n+1,-1) ; 
   int ct = 0;
   // iterate in reverse finishing order
   for(int i=(int)topo.size()-1 ; i>=0; i-- ) {
        int node = topo[i];
        if(comp[node]==-1) {
            dfs2(node,ct++);
        }
   }

   // we have assigned a color to every SCC 

   // NOW we can compress every SCC with new nodes 
   // initialize with large min and small max
   vector<pair<int,int>> b(ct, make_pair((int)1e9, (int)-1e18));  // {min, max}

   for (int i=1; i<=n; i++){
        int c = comp[i];
        b[c].first = min(b[c].first, val[i]);
        b[c].second = max(b[c].second, val[i]);
   }

   // build compressed DAG (b_graph) where nodes are components 0..ct-1
   b_graph.clear();
   b_graph.resize(ct);
   vi indeg(ct, 0);

   for (int u = 1; u <= n; u++) {
       for (auto v : g[u]) {
           int cu = comp[u];
           int cv = comp[v];
           if (cu != cv) {
               b_graph[cu].pb(cv);
               indeg[cv]++; // note: duplicates not removed
           }
       }
   }

   // Example output: print number of components and for each component min/max/indegree
   cout << "SCC count: " << ct << '\n';
   for (int c = 0; c < ct; c++) {
       cout << "Comp " << c << ": min=" << b[c].first << " max=" << b[c].second 
            << " indeg=" << indeg[c] << " outdeg=" << sz(b_graph[c]) << '\n';
   }

   // At this point you can proceed with further processing on the DAG (b_graph)
   // (kept minimal â€” left further algorithmic steps to your problem statement)
}

signed main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    int t = 1;
    // cin >> t;
    while (t--)
        solve();
        
    return 0;
}
